# lab-3 实验报告

## 原理1

> 在 os/src/entry.asm 中，boot_page_table 的意义是什么？当跳转执行 rust_main 时，不考虑缓存，硬件通过哪些地址找到了 rust_main 的第一条指令？

boot_page_table 的意义是作为一个初始的页表，建立虚拟地址和物理地址的映射关系，使得内核代码储存在较高的虚拟地址上，而物理地址储存在较低的物理地址上，让 CPU 可以正确读取并执行内核代码。

在跳转执行 rust_main 时，硬件首先通过 setp 寄存器的值跳转至 boot_page_table 的起始地址，根据虚拟地址的值查表得到对应的页表项：第[38:30]位对应第 510 项（`0xffff_ffff_8020_0000 => [1..1][111111110][offset]`）。该页表项的 flags 对应位为 0xcf，其中的 XWR 位说明当前页表项是一个索引 1G 页面的页表项（也就是最后的 30 个 bit 都是页内偏移），直接将虚拟地址最高的9位替换为对应的物理地址的高26位（PPN[2]）。在 entry.asm 定义的 boot_page_table 中，对应的页表项储存的物理地址为`(0x80000 << 10) | 0xcf`，后面的 0xcf 代表设定的 flags，前面的 0x80000 虚拟页号对应的 44 位物理地址的高32位（总体的物理页号）。最终跳转的地址位置应该为 0x8020_0000 地址后实际储存内核程序的部分。

## 分析1

> 为什么 Mapping 中的 page_tables 和 mapped_pairs 都保存了一些 FrameTracker？二者有何不同？

page_tables 保存 FrameTracker 是为了储存和访问页表，对应的物理帧储存是线程所分配页面的页表的内容； mapped_pairs 保存 FrameTracker 是为了储存和访问一个线程所分配空间对应的物理空间，对应储存的内容是线程所利用的空间的物理内存内容。

## 分析2

> 假设某进程需要虚拟地址 A 到物理地址 B 的映射，这需要操作系统来完成。那么操作系统在建立映射时有没有访问 B？如果有，它是怎么在还没有映射的情况下访问 B 的呢？

建立映射的时候没有访问 B 。操作系统在建立映射的时候只要知道地址的映射关系，即 A 与 B 两个地址的值便可以进行页表项的修改（因为页表所对应的物理地址是已知的）。

另：答案中提示道应用程序可能需要操作系统在建立映射的同时向页面中加载一些数据，操作系统可以做到这点因为整个可用的物理内存地址已经建立过内核映射（内核可以访问全部的物理地址空间，这也是理所应当的，否则内核就无法管理物理内存），内核可以通过线性偏移访问到 B 。

## 实验

> 了解并实现时钟页面置换算法（或任何你感兴趣的算法），可以自行设计样例来比较性能
> * 置换算法只需要修改 os/src/memory/mapping/swapper.rs
> * 在 main.rs 中调用 create_kernel_thread 来创建线程，你可以任意修改其中运行的函数，以达到测试效果

详见`swapper.rs`中的 ClockSwapper 的实现以及`main.rs`的修改。
