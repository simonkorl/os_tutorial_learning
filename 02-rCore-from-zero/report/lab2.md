# lab-2 实验报告

## 原理

> .bss 字段是什么含义？为什么我们要将动态分配的内存（堆）空间放在 .bss 字段？

.bss 字段是 ELF 可执行文件中的一段被预先初始化为 0 的段，可以用来储存程序中未初始化的全局变量以及静态变量（初始化的值为 0 可以认为是没有初始化）。这个段的特点是申请在 .bss 字段储存的变量并不实际占用内存空间，而是记录了申请地址的起始地址以及长度。

将这段动态分配的内存放在 .bss 段实际上是一种简单的实现方法，并非必须。实际上堆空间一般是用户程序或者库向操作系统申请的某一段连续地址空间，内核只需要提供分配连续物理地址空间的功能即可。而本次实现中，我们可以自由地访问所有的地址空间（就比如说可以直接得知 DRAM 的地址位置），使用 .bss 段可以让这段地址空间自动清零，并且可以让堆空间在内核代码中，使得其不影响其他进程的代码空间。

## 分析

> 我们在动态内存分配中实现了一个堆，它允许我们在内核代码中使用动态分配的内存，例如 Vec Box 等。那么，如果我们在实现这个堆的过程中使用 Vec 而不是 [u8]，会出现什么结果？
> 选项：
> 无法编译？
> 运行时错误？
> 正常运行？

在分析的角度上来讲，使用需要利用堆分配机制的结构实现堆的分配算法应该会导致循环引用，从而导致编译不通过。

不过答案认为程序可以正确执行且陷入死循环，目前我没有想到实现与测试的方法，还不清楚结果究竟如何。

## 实验

### 实验一

> 回答：algorithm/src/allocator 下有一个 Allocator trait，我们之前用它实现了物理页面分配。这个算法的时间和空间复杂度是什么？

目前的 Allocator 使用了栈式的维护方法。通过将分配的单元记录在栈中来记录空间的分配。（神奇的是虽然 Allocator 使用的是栈进行实现，整个程序实际上并没有出现任何运行问题。理论上 Vec 在申请空间的时候使用 Vec 进行实现肯定会产生嵌套的问题，不过实际上并没有事情发生）

时间复杂度为 O(1)，每次只需要维护栈顶的一个元素。空间复杂度为 O(n)，最差的情况下分配完毕全部的元素，又重新释放空间。因为没有合并的功能，所以最终会有 O(n) 的空间代价，n 为分配元素的个数。

这个分配元素不仅是以字节为大小，也可以以页、帧作为大小，按照页号进行分配。Allocator 一次只能分配一个元素。

### 实验二

> 二选一：实现基于线段树的物理页面分配算法（不需要考虑合并分配）；或尝试修改 FrameAllocator，令其使用未被分配的页面空间（而不是全局变量）来存放页面使用状态。

## 挑战实验（选做）

### 实验一

> 在 `memory/heap2.rs` 中，提供了一个手动实现堆的方法。它使用  `algorithm::VectorAllocator` 作为其根本分配算法，而我们目前提供了一个非常简单的 `bitmap` 算法（而且只开了很小的空间）。请在 `algorithm` crate 中利用伙伴算法实现 `VectorAllocator` trait。

### 分析

> 前面说到，堆的实现本身不能完全使用动态内存分配。但有没有可能让堆能够利用动态分配的空间，这样做会带来什么好处？
