# rust学习日志

## 2020.9.19

完成Hello World部分的学习

根据这个教程来说，这部分的学习稍微有一点困难。因为我们并不是非常了解rust语言的trait机制，也不太清楚一些接口与实现的部分。给人的感觉是这部分的内容与java，python和c都有相似之处。

有关打印的部分非常类似于python的print方法。有关方法重载的Debug部分非常类似于python的magic function。这部分如果学习过python应该会理解起来更加简单。

复写的rust函数也与python有异曲同工之处，都是具有一个self变量，格式上python也可以这么标记，只不过写法不太一样。

我的话建议在看这个教程之前至少对一门常见的编程语言非常熟悉，比如说C，C++，Python，Java这些。至少需要对程序中出现的大多数东西很熟悉。此外我觉得在看这个教程前对rust的一些基本概念，比如说数据类型和所有权有一个基础的认识，看这个教程的难度应该会下降不少。

## 2020.9.20

完成Primitive部分的学习

很多的数据类型和python很相似。比较难的是理解Array的所有权，但是这一章并没有提这件事，只是说了borrow

Array在编译的时候就确定了大小，不能改变。编译的时候便会动态检查可能出现的访问异常。

## 2020.9.21

流程控制：

if与python很像，并不需要写括号，但是所有的运算符与C是相同的

循环：

while 与所有语言的while工作原理相同，没有do while语法

loop 相当于while(1)

for 与python的for含义相同，只能遍历迭代器。使用0..4这样的标志表示数字迭代器，左闭右开。如果使用0..=4则两边都是闭。

match：非常关键的关键词，可以将条件进行分发。目前可以完成如同switch的工作，可以判断条件是否落在某个区间，并且可以记录下落在区间上的数值。

返回值：

rust的流程返回值非常有趣，对于任何一个块，只要最后一个语句是一个没有分号的表达式，那么编译器会认为它是一个返回值，否则则不是一个返回值。所有if分支的返回值类型必须相同（或者共享一个基类）（因为rust是强类型语言，一个函数只能返回特定类型的）。这部分如果编译原理课程进行过java实验的话，对于这部分肯定会有印象，其中有一个实验就是要判断block的返回值是否类型相同。

结构体：结构体的声明类似于很多类C语言，需要标记每一个元素的类型，与python不尽相同。比较类似typescript

enum：枚举类更像是C的union，可以拥有很多不同类型但是每次只能选用一个，占用其中最大的空间的数据结构。

模板<T>，与类C语言的模板没有太大区别。手动声明模板类型时需要使用::<T>，

Option<T>: 原生enum类型，只有None与Some<T>两种类型。可以靠item.is_some()或者item.is_none()来判断是否具有内容。不会像javascript那样不确定是否存在某个元素

Result<T,E>：原生enum类型，只有Ok(T)与Err(E)两个选项

？标志：代表一个操作可能成功或失败，失败后不执行后续操作。

所有权：

和C++比较像的一点是rust会在每一个scope结束时按照创建顺序的倒序回收临时变量，除非它的所有权发生了转移。这个释放的过程被称为drop。和C++的类的析构基本上一致，构造的时候从最内层开始构造，析构的时候从最外侧开始析构。

### 所有权的操作

1. move：使用函数传递的时候所有权发生移动。如果该变量没有被返回，则该变量将会在函数的最后释放
2. borrow：使用&在变量前面，与C++的reference一致。你将获得一个类似于所有权的常量指针，可以对内容进行访问，但是不能修改。
3. mutable borrow：使用&mut变量可以获得一个可以修改的所有权，类似于C++的普通reference，如果想要修改原始的数据，原始数据也需要是mutable的（就像C++中你不可以利用reference修改常量）。在mutable borrow时原拥有者不能移动或是修改（可以认为这是一个同步的过程，一次只允许一个所有者对一个数据进行修改，但是允许多个所有者对变量进行读操作。这在异步操作时可以带来较大的安全性）
4. \*：rust没有指针的概念，\*只是用来取值的。利用 \*mutable borrow 来修改reference的值。同时可以使用\*对一个mutable borrow的原始值进行一个值的拷贝，获得一个全新的数据。
5. 两条规则：一、任何一个数据只能同时有一个可变ref或是若干不可变ref并且这两者只能取其一。可以认为rust认为变量应该是一个读写的互斥操作；二、任何ref不能比owner的存活时间长
6. 注：owner和reference不是一个概念。owner是一个值绑定的变量，可以有很多个reference从owner那里获取使用权，但是需要满足读写互斥的规则。owner释放之后，所有的reference都会失效。和操作系统的概念进行比较的话，owner类似于inode，data就是储存的数据，reference是硬链接。不过概念不同的地方是，一旦有了硬链接，原始的inode就不能用于访问。
7. 注：rust的&符号优先级比较低，&foo.x是返回x的reference，但是C++的&foo.x返回的是对应地址位置的x的值。
8. 生命周期标识符\'，在函数中可以使用<\'a>等符号表示变量的生命周期，这个生命周期的标注必须正确
9. static生命周期，所有标记为static的变量据具有`'static`的生命周期并且所有对它的reference必须也是`’static`生命周期

