# rust学习日志

## 2020.9.19

完成Hello World部分的学习

根据这个教程来说，这部分的学习稍微有一点困难。因为我们并不是非常了解rust语言的trait机制，也不太清楚一些接口与实现的部分。给人的感觉是这部分的内容与java，python和c都有相似之处。

有关打印的部分非常类似于python的print方法。有关方法重载的Debug部分非常类似于python的magic function。这部分如果学习过python应该会理解起来更加简单。

复写的rust函数也与python有异曲同工之处，都是具有一个self变量，格式上python也可以这么标记，只不过写法不太一样。

我的话建议在看这个教程之前至少对一门常见的编程语言非常熟悉，比如说C，C++，Python，Java这些。至少需要对程序中出现的大多数东西很熟悉。此外我觉得在看这个教程前对rust的一些基本概念，比如说数据类型和所有权有一个基础的认识，看这个教程的难度应该会下降不少。

## 2020.9.20

完成Primitive部分的学习

很多的数据类型和python很相似。比较难的是理解Array的所有权，但是这一章并没有提这件事，只是说了borrow

Array在编译的时候就确定了大小，不能改变。编译的时候便会动态检查可能出现的访问异常。

## 2020.9.21

> 这一天换了参考资料，主要学习了Tour of Rust。这边的每一章内容都更小，接触核心概念更早，我认为更加适合第一次接触时学习。
>
> Rust By Examples 中很多概念可能会混淆在一起，后面的东西还没有学习到的时候就已经开始使用到了。对于刚开始学习Rust的人来说并不是很友好。

流程控制：

if与python很像，并不需要写括号，但是所有的运算符与C是相同的

循环：

while 与所有语言的while工作原理相同，没有do while语法

loop 相当于while(1)

for 与python的for含义相同，只能遍历迭代器。使用0..4这样的标志表示数字迭代器，左闭右开。如果使用0..=4则两边都是闭。

match：非常关键的关键词，可以将条件进行分发。目前可以完成如同switch的工作，可以判断条件是否落在某个区间，并且可以记录下落在区间上的数值。

返回值：

rust的流程返回值非常有趣，对于任何一个块，只要最后一个语句是一个没有分号的表达式，那么编译器会认为它是一个返回值，否则则不是一个返回值。所有if分支的返回值类型必须相同（或者共享一个基类）（因为rust是强类型语言，一个函数只能返回特定类型的）。这部分如果编译原理课程进行过java实验的话，对于这部分肯定会有印象，其中有一个实验就是要判断block的返回值是否类型相同。

结构体：结构体的声明类似于很多类C语言，需要标记每一个元素的类型，与python不尽相同。比较类似typescript

enum：枚举类更像是C的union，可以拥有很多不同类型但是每次只能选用一个，占用其中最大的空间的数据结构。

模板<T>，与类C语言的模板没有太大区别。手动声明模板类型时需要使用::<T>，

Option<T>: 原生enum类型，只有None与Some<T>两种类型。可以靠item.is_some()或者item.is_none()来判断是否具有内容。不会像javascript那样不确定是否存在某个元素

Result<T,E>：原生enum类型，只有Ok(T)与Err(E)两个选项

？标志：代表一个操作可能成功或失败，失败后不执行后续操作。

所有权：

和C++比较像的一点是rust会在每一个scope结束时按照创建顺序的倒序回收临时变量，除非它的所有权发生了转移。这个释放的过程被称为drop。和C++的类的析构基本上一致，构造的时候从最内层开始构造，析构的时候从最外侧开始析构。

### 所有权的操作

1. move：使用函数传递的时候所有权发生移动。如果该变量没有被返回，则该变量将会在函数的最后释放
2. borrow：使用&在变量前面，与C++的reference一致。你将获得一个类似于所有权的常量指针，可以对内容进行访问，但是不能修改。
3. mutable borrow：使用&mut变量可以获得一个可以修改的所有权，类似于C++的普通reference，如果想要修改原始的数据，原始数据也需要是mutable的（就像C++中你不可以利用reference修改常量）。在mutable borrow时原拥有者不能移动或是修改（可以认为这是一个同步的过程，一次只允许一个所有者对一个数据进行修改，但是允许多个所有者对变量进行读操作。这在异步操作时可以带来较大的安全性）
4. \*：rust没有指针的概念，\*只是用来取值的。利用 \*mutable borrow 来修改reference的值。同时可以使用\*对一个mutable borrow的原始值进行一个值的拷贝，获得一个全新的数据。
5. 两条规则：一、任何一个数据只能同时有一个可变ref或是若干不可变ref并且这两者只能取其一。可以认为rust认为变量应该是一个读写的互斥操作；二、任何ref不能比owner的存活时间长
6. 注：owner和reference不是一个概念。owner是一个值绑定的变量，可以有很多个reference从owner那里获取使用权，但是需要满足读写互斥的规则。owner释放之后，所有的reference都会失效。和操作系统的概念进行比较的话，owner类似于inode，data就是储存的数据，reference是硬链接。不过概念不同的地方是，一旦有了硬链接，原始的inode就不能用于访问。
7. 注：rust的&符号优先级比较低，&foo.x是返回x的reference，但是C++的&foo.x返回的是对应地址位置的x的值。
8. 生命周期标识符\'，在函数中可以使用<\'a>等符号表示变量的生命周期，这个生命周期的标注必须正确
9. static生命周期，所有标记为static的变量据具有`'static`的生命周期并且所有对它的reference必须也是`’static`生命周期

## 2020.9.22

> 了解了一些基础后回归 RBE（Rust By Example）

### Variable Bindings

Rust的变量定义和javascript和python有一定相似度，内存的分配和变量名的定义可能有一定区别。C与C++则是每一个变量名都会直接分配对应的空间和地址。

1. 虽然Rust是强类型语言，但是variable shadowing可以将不同类型的变量绑定到同一个变量上。但是之前的变量便会被丢弃。（使用 let，这个关键词在javascriptES6中被提出，代表一种块作用域。如果学过编译原理的话肯定对这些作用域印象深刻）
2. 变量可以先用let声明之后绑定值，不过用法不常见。在C中还是非常常见的操作。
3. 可以使用名字相同的变量进行freeze操作，即取消它在作用域中的可变特征。不过即使不进行freeze操作，只要作用域不同还是可以使用相同的变量名进行shadowing

```rust
fn main() {
    let _mutable_integer = 7i32;
    println!("{}", _mutable_integer);
    {
        // Shadowing
        let _mutable_integer = 'a';
        println!("{}", _mutable_integer);

        // `_mutable_integer` goes out of scope
    }

    println!("{}",_mutable_integer);
    // 7
    // a
    // 7
}

```

### Types

1. 类型转换：不允许未声明清楚类型的强制类型转换，同时有一些限制。但是除此之外和C应该是一样的，在二进制层面上原理相同。
2. 数字Literal（也就是直接声明的数字）可以直接在后面标注类型`2u8`，大小和描写的相同。数字默认为整型32与浮点64，与64位C++相同，
3. Rust的编译器很强大，有的时候可以可以自动推断一些变量的类型，比如说vec<>
4. 定义的类型必须是UpperCamelCase

### Conversion

大类型之间的转化。From是一个trait，或者说python中的magic function。实现一个泛型的实例就可以完成类型的转化，Into是它的逆向操作。

1. TryFrom TryInto 带有Result和可能错误的转化
2. 与字符串的转化：可以实现ToString函数，不过直接实现fmt::Display会更加方便

### Expression

> 编译原理永远的痛

使用;结尾的句子都是表达式，{}也是表达式。这个在编译原理中应该已经深有体会，完成的任务中如果有Lambda表达式的话则是让人深恶痛绝。

### Flow of Control

流控的不少内容之前也看过了，其中match的用法非常灵巧。记住match对应的default是符号`_`

Rust的reference和pointer和C++非常类似。其中最大的区别相当于是在C++中默认增加了const关键字。

:star:if let，这个关键字在C与C++中还比较常见，是用来赋值并且判断，判断出的结果需要有错误的类型，比如说None（来自Option）

### Functions

rust的函数不需要担心函数的先后顺序。

无返回值的函数不需要标注返回值类型，默认返回()，空tuple是最基本的默认类型。

#### Methods

非常神奇的是，Rust的类的概念似乎比较散。所有的结构体、tuple都是可以被定义成员函数的。

所有没有被传入self的函数都被认为是静态函数

#### 闭包（lambda表达式）

> 又到了编译原理的噩梦了

rust的lambda表达式是我见过lambda表达式中外形最为奇怪的。

```rust
let closure_annotated = |i: i32| -> i32 { i + 1 };
let closure_inferred  = |i     |          i + 1  ;
```

使用`| |`代替小括号进行函数的编写。可以非常智能地进行类型分析。

但是lambda表达式本身的内容是需要考虑很多有关所有权的内容的。

关于lambda表达式的mut标志，实际上和C++的const function有相似之处。对于rust，只要lambda当中需要改变一个mut变量，那么就需要标志为mut类型，来借用变量。（在C++中的变量引用需要手动标注是按值或按ref）

除非明确在lambda表达式前面标记move，否则都是直接借用而不是挪用。也就是默认按照ref进行变量借用。

##### 传入lambda表达式

> 我曾经在Java中对java的lambda表达式深恶痛疾，其中关键之处就是Java对于Lambda表达式有一些非常奇怪的定义，Lambda表达式本质上是某些函数，必须要契合某种Interface



Rust在这方面可能有些相似。传入的闭包必须明确标注一些类型：

* Fn：按不变ref传值
* FnMut：按可变ref传值
* FnOnce: 按值传值，这会导致move 

### Rustlings练习

> 闭包的知识实在是太多了，没有耐心来看了。做一些简单的练习题巩固一下之前的知识

根据建议，下面的做题顺序与`rustlings watch`命令编译的顺序相同。

主要记录一下自己在哪里做错了，或是不太清楚的地方。

#### variables

variables6：const变量命名需要显式指定变量类型

#### if

if1: 经典的二元选择式，别忘了加括号

#### functions

functions2：Rust的函数需要显式指定输入变量的类型。如果没有输出则可以不指定输出的类型。【这么做的想法应该是在静态检查的时候让编译器明白你其实是想做些什么】

functions5：仔细看，那个函数表达式最后有分号！这种错误简直就是找不同，幸好编译器会给提示

#### primitive_types

3： Rust中的数组概念稍微优点不同，定义与初始化方法要记清楚`[;]`

4：Beginner’s luck要用完了，语法特点要开始发威了！slice并不需要声明类型，但是需要使用&a[1..4]进行借用。还要记住，slice标志中所有的都是下标。

5：tuple的展开不需要指定类型

6：tuple不像数组那样用下标，而是用`.2`这样的数字对象进行访问